# conways-opencl

High-performance implementation of Conway’s Game of Life using both OpenCL and scalar (CPU) approaches. This project, developed as the final assignment for the High-Performance Computer Architectures course, demonstrates advanced parallel computing techniques, efficient memory management, and robust simulation strategies.

## Requirements

- **CMake** (version 3.15 or later)
- **OpenCL SDK**
- **C++17 Compiler** (MinGW-w64 or equivalent for Windows)
- **Windows build tools** (MSYS2 recommended) or Linux/WSL for a more stable environment

## Directory Structure

- **include/**: Header files (e.g., `GameOfLife.h`, `CLI.h`)
- **src/**: Source code files (e.g., `GameOfLife.cpp`, `CLI.cpp`, `main.cpp`, `gol_opencl.cpp`, `performance_measure.cpp`, `test_save.cpp`)
- **build/**: Build directory (generated by CMake)

## Build

Open a terminal and navigate to the project root. Then, create a build directory and run CMake:

```powershell
mkdir build
cd build
cmake ..
cmake --build . --target game_of_life gol_opencl performance_measure test_save
```
### This will build the following executables:

    game_of_life.exe – The interactive CLI version.
    gol_opencl.exe – The standalone OpenCL evolution executable.
    performance_measure.exe – The performance measurement tool.
    test_save.exe – A test executable for verifying file I/O functionality.

## Running the Project

From the build folder, run:
CLI Version
```poweshell
./game_of_life.exe
```

The CLI supports the following commands:

  - create: Create a new world (prompts for width and height)
  - load: Load a world from a file (prompts for filename)
  - save: Save the current world to a file (prompts for filename)
  - run <mode> <n>: Run the simulation for n generations
        scalar: CPU-based evolution
        opencl: OpenCL (GPU/CPU-based) evolution
  - set: Set the state of a cell (prompts for coordinates and state)
  - get: Get the state of a cell (prompts for coordinates)
  - glider: Insert a "Glider" pattern at a specified position
  - toad: Insert a "Toad" pattern at a specified position
  - beacon: Insert a "Beacon" pattern at a specified position
  - methuselah: Insert a Methuselah pattern at a specified position
  - print on/off: Enable or disable printing after each generation
  - delay <ms>: Set the delay (in milliseconds) for simulation
  - help: Display this help message
  - exit / quit: Exit the program

## OpenCL Direct Execution

```poweshell
./gol_opencl.exe <width> <height> <generations>
```
Example:

```poweshell
./gol_opencl.exe 10 10 1000
```

Performance Measurement
```poweshell
./performance_measure.exe
```

This executable runs simulations on various grid sizes, outputs a CSV file (simulation_results.csv), and can be used to generate performance plots.
```poweshell
./test_save.exe
```

This executable tests the file I/O functionality by creating a 10×10 world, printing the grid, and saving it to a file (test_save_output.txt).
Additional Information

  - Toroidal Grid: The grid wraps around at the edges, ensuring that every cell always has eight neighbors. This simplifies the neighbor calculation and avoids edge-case handling.
  - Double Buffering: Two separate buffers are used to store the current and next generation of cell states. After updating, the buffers are swapped to ensure consistent updates.
  - OpenCL Parallelization: The OpenCL kernel is designed so that each work-item computes the next state of a single cell. This allows for significant acceleration on parallel hardware.
  - Memory Management: We use STL containers (e.g., std::vector) to manage memory safely and efficiently, leveraging RAII to avoid manual memory management pitfalls.
  - Race Conditions: The design inherently avoids race conditions by using double buffering and ensuring that each computation writes to a separate memory location (especially in the parallel OpenCL kernel).
